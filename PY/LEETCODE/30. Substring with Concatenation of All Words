class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        wlets = str()
        for i in words: wlets += i
        wlets = list(wlets)
        find = 0
        for i in wlets:
            if i in s:
                find = 1
                break
        if (find != 1): return([])


        #get permutation indices
        #create concatenated substring
        #check if concatenated substring exists in s
        # if yes, add the index of s into the output list
        # if not, continue with the next permutation
        retlist=list()

        l1 = list(range(len(words)))
        pt = prt = len(l1) - 2
        #print(l1)
        csub = str()
        for i in l1: csub += words[i]

        indices = []
        start_index = 0
        while True:
            # Find the next occurrence starting from start_index
            index = s.find(csub, start_index)
            if index == -1: break
            # Add the found index to the list
            indices.append(index)
            # Update the start_index to search for the next occurrence
            start_index = index + 1
        retlist += indices

        while (pt >= 0):
        # if any elements to the right of index are greater than element at index
            if any(x > l1[pt] for x in l1[pt + 1:]):
                #sort the elements to the right of index
                rhsorted = sorted(l1[pt + 1:])
                l1 = l1[0:pt+1] + rhsorted

                #take lowest greater than the index value and swap with index
                first_grt = next((n for n in rhsorted if n > l1[pt]), None)
                rloc = rhsorted.index(first_grt)
                tmp = l1[pt]
                l1[pt] = l1[pt + rloc + 1]
                l1[pt + rloc + 1] = tmp

                # then print
                #print(l1)
                csub = str()
                for i in l1: csub += words[i]
                
                indices = []
                start_index = 0
                while True:
                    # Find the next occurrence starting from start_index
                    index = s.find(csub, start_index)
                    if index == -1: break
                    # Add the found index to the list
                    indices.append(index)
                    # Update the start_index to search for the next occurrence
                    start_index = index + 1
                retlist += indices

                #then reset the pointer to the far right and start over
                pt = prt
            else:
                #shift index left by one and start over until we hit the far left.
                pt -= 1

        return(list(set(retlist)))
