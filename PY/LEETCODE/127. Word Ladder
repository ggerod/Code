def good_step(w1, w2):
    #see if w1 and w2 are off by one letter only
    dcount = 0
    for i in range(len(w1)):
        if (w1[i] != w2[i]):
            dcount += 1
            if dcount > 1:
                return(False)
    return(True)

def check_valid_path(beginWord, endWord, perm, wlist):
    plen = 0
    curWord = beginWord
    for i in range(len(perm) - 1):
        pind = perm[i]
        if good_step(curWord, wlist[pind]):
            if (wlist[pind] == endWord):
                return(i + 1)
            curWord = wlist[pind]
        else:
            return(0)
    return(0)


class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        # if last word not in wordlist end
        if (endWord not in wordList): return(0)

        # make every permutation
        # for each permutation, determine if valid perm, if valid note length
        shortestlen=0

        l1 = list(range(len(wordList)))
        pt = prt = len(l1) - 2

        plen = check_valid_path(beginWord, endWord, l1, wordList)
        if plen != 0:
            #we have a valid path.  See if it is shortest found.
            if (shortestlen == 0):
                shortestlen = plen
            else:
                if (plen < shortestlen):
                    shortestlen = plen

        while (pt >= 0):
            # if any elements to the right of index are greater than element at index
            if any(x > l1[pt] for x in l1[pt + 1:]):
                #sort the elements to the right of index
                rhsorted = sorted(l1[pt + 1:])
                l1 = l1[0:pt+1] + rhsorted

                #take lowest greater than the index value and swap with index
                first_grt = next((n for n in rhsorted if n > l1[pt]), None)
                rloc = rhsorted.index(first_grt)
                tmp = l1[pt]
                l1[pt] = l1[pt + rloc + 1]
                l1[pt + rloc + 1] = tmp

                plen = check_valid_path(beginWord, endWord, l1, wordList)
                if (plen != 0):
                    #we have a valid path.  See if it is shortest found.
                    if (shortestlen == 0):
                        shortestlen = plen
                    else:
                        if (plen < shortestlen):
                            shortestlen = plen

                #then reset the pointer to the far right and start over
                pt = prt
            else:
                #shift index left by one and start over unless we are already at far left and are done.
                pt -= 1
            
        # return the shortest length or 0 if none found
        if (shortestlen == 0): return(0)

        return(shortestlen + 1)
